//version:2.4.4
//time 15:14 3/3
//Program 1
//INSTRUCTIONS:
//1
//set index register
//DATA:
000000001000,0000000001000000
000000001001,0000000010101010
000001010101,0111111111111111
000001010110,0000000001000000
000001010111,0000000001010100
//ix1 <==Addr[8]
000001111110,1000010001001000
//ix2 <== Addr[9]
000001111111,1000010010001001
//IN r0 IX=00 I=0 Addr=Keyboard
000010000000,1100010000000000
//STR r0 IX=00 I=0 Addr=64
000010000001,0000100001000000
//2
//IN r0 IX=00 I=0 Addr=Keyboard
000010000010,1100010000000000
//STR r0 IX=00 I=0 Addr=65
000010000011,0000100001000001
//3
//IN r0 IX=00 I=0 Addr=Keyboard
000010000100,1100010000000000
//STR r0 IX=00 I=0 Addr=66
000010000101,0000100001000010
//4
//IN r0 IX=00 I=0 Addr=Keyboard
000010000110,1100010000000000
//STR r0 IX=00 I=0 Addr=67
000010000111,0000100001000011
//5
//IN r0 IX=00 I=0 Addr=Keyboard
000010001000,1100010000000000
//STR r0 IX=00 I=0 Addr=68
000010001001,0000100001000100
//6
//IN r0 IX=00 I=0 Addr=Keyboard
000010001010,1100010000000000
//STR r0 IX=00 I=0 Addr=69
000010001011,0000100001000101
//7
//IN r0 IX=00 I=0 Addr=Keyboard
000010001100,1100010000000000
//STR r0 IX=00 I=0 Addr=70
000010001101,0000100001000110
//8
//IN r0 IX=00 I=0 Addr=Keyboard
000010001110,1100010000000000
//STR r0 IX=00 I=0 Addr=71
000010001111,0000100001000111
//9
//IN r0 IX=00 I=0 Addr=Keyboard
000010010000,1100010000000000
//STR r0 IX=00 I=0 Addr=72
000010010001,0000100001001000
//10
//IN r0 IX=00 I=0 Addr=Keyboard
000010010010,1100010000000000
//STR r0 IX=00 I=0 Addr=73
000010010011,0000100001001001
//11
//IN r0 IX=00 I=0 Addr=Keyboard
000010010100,1100010000000000
//STR r0 IX=00 I=0 Addr=74
000010010101,0000100001001010
//12
//IN r0 IX=00 I=0 Addr=Keyboard
000010010110,1100010000000000
//STR r0 IX=00 I=0 Addr=75
000010010111,0000100001001011
//13
//IN r0 IX=00 I=0 Addr=Keyboard
000010011000,1100010000000000
//STR r0 IX=00 I=0 Addr=76
000010011001,0000100001001100
//14
//IN r0 IX=00 I=0 Addr=Keyboard
000010011010,1100010000000000
//STR r0 IX=00 I=0 Addr=77
000010011011,0000100001001101
//15
//IN r0 IX=00 I=0 Addr=Keyboard
000010011100,1100010000000000
//STR r0 IX=00 I=0 Addr=78
000010011101,0000100001001110
//16
//IN r0 IX=00 I=0 Addr=Keyboard
000010011110,1100010000000000
//STR r0 IX=00 I=0 Addr=79
000010011111,0000100001001111
//17
//IN r0 IX=00 I=0 Addr=Keyboard
000010100000,1100010000000000
//STR r0 IX=00 I=0 Addr=80
000010100001,0000100001010000
//18
//IN r0 IX=00 I=0 Addr=Keyboard
000010100010,1100010000000000
//STR r0 IX=00 I=0 Addr=81
000010100011,0000100001010001
//19
//IN r0 IX=00 I=0 Addr=Keyboard
000010100100,1100010000000000
//STR r0 IX=00 I=0 Addr=82
000010100101,0000100001010010
//20
//IN r0 IX=00 I=0 Addr=Keyboard
000010100110,1100010000000000
//STR r0 IX=00 I=0 Addr=83
000010100111,0000100001010011
//request from user
//IN r0 IX=00 I=0 Addr=Keyboard
000010101000,1100010000000000
//STR r0 IX=00 I=0 Addr=84
000010101001,0000100001010100
//X2偏移值为170
//PC = 170
//Address[84]存放user输入的值，Address[85]存储当前最小差值，Address[86]存储64，Address[87]存储84
//对比循环开始
//R0: User input number
//@170
//LDR r0, x1, 20 [0]
000010101010,0000010001010100
//r0 = r0 - address[address[86]]
//@171
//SMR 00, 01, 22 [1]
000010101011,0001010001110110
//判断r0正负
//if r0>=0 跳转到对比Min和r0的方法
//@172
//JGE 00, x2, address [0]   //跳转到175
000010101100,0011110010000101
//否则求r0的绝对值
//@173
//NOT R0     //取反
000010101101,0101010000000000
//@174
//AIR r0, 1 //加一
000010101110,0001100000000001
//对比Min和r0
//@175
//SMR r0, x1, 21[0]  //r0-min
000010101111,0001010001010101
//如果结果大于零，则不需要操作，跳转到Address[86]+1指令
//@176
//JGE r0, x2, address [0] //Address[86]+1指令位置  @180
000010110000,0011110010001010
//如果结果小于0，说明r0是更好的结果，就要进行替换
//先加上Address[85]的值，在存放心Address【85】
//@177
//AMR r0, x1, 21[0]
000010110001,0001000001010101
//@178
//STR r0, x1, 21[0]
000010110010,0000100001010101
//将Address[86]对应的的值放进r3存储
//@179
//LDR r3, x1, 22[1]
000010110011,0000011101110110
//Address[86]+1
//Load Address[86] to r1
//@180
//LDR r1, x1, 22 [0]
000010110100,0000010101010110
//r1+1
//@181
//AIR r1,1
000010110101,0001100100000001
//Store R1 to Address[86]
//@182
//STR r1,x1,22[0] //间接寻址86
000010110110,0000100101010110
//判断循环是否结束（r1[new Address[86]] - Address[87] = 0）
//if r1-Address[87] = 0 循环结束
//@183
//SMR r1, x1, 23 [0]
000010110111,0001010101010111
//@184
//JNE r1, x2, address[0]//不等于0 跳转到循环开始的语句 @170
000010111000,0010010110000000
//否则循环结束，输出R3
//@185
//OUT r3, outputID
000010111001,1100101100000001